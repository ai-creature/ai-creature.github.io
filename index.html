 <!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>The AI Creature</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <!-- tf.js -->
        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.12.0/dist/tf.min.js"></script>

        <script src="agent_sac.js"></script>
        
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            #testCanvas0 {
                position:absolute;
                width: 128px;
                height: 64px;
                right:450px;
                bottom: 0;
            }

            #testCanvas1 {
                position:absolute;
                width: 128px;
                height: 64px;
                right: 300px;
                bottom: 0;
            }

            #testCanvas2 {
                position:absolute;
                width: 128px;
                height: 64px;
                right: 150px;
                bottom: 0;
            }

            #testCanvas3 {
                position:absolute;
                width: 128px;
                height: 64px;
                right: 0px;
                bottom: 0;
            }
        </style>
    </head>
    <body>
        <canvas id="renderCanvas"></canvas>
        <canvas id="testCanvas0"></canvas>
        <canvas id="testCanvas1"></canvas>
        <canvas id="testCanvas2"></canvas>
        <canvas id="testCanvas3"></canvas>
        <script>
            const print = (...args) => console.log(...args)
            
            window.engine = null;
            window.scene = null;
            window.sceneToRender = null;

            const agent = new AgentSac({trainable: false, verbose: false})
            const canvas = document.getElementById("renderCanvas");
            const createDefaultEngine = function() { 
                return new BABYLON.Engine(canvas, true, {
                    preserveDrawingBuffer: true, 
                    stencil: true,  
                    disableWebGL2Support: false
                }); 
            };

            const createScene = async function () {
                // This creates a basic Babylon Scene object (non-mesh)
                const scene = new BABYLON.Scene(engine);

                // Environment
                const hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData("3d/env/environment.dds", scene);
                hdrTexture.name = "envTex";
                hdrTexture.gammaSpace = false;
                scene.environmentTexture = hdrTexture;
            
                const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
                const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("3d/env/skybox", scene);
                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                skybox.material = skyboxMaterial;
            
                //CAMERA
                const camera = new BABYLON.ArcRotateCamera("Camera", BABYLON.Tools.ToRadians(-120), BABYLON.Tools.ToRadians(80), 65, new BABYLON.Vector3(0, -15, 0), scene);    
                camera.attachControl(canvas, true);
                camera.lowerRadiusLimit = 10;
                camera.upperRadiusLimit = 120;

                //enable Physics in the scene vector = gravity
                scene.enablePhysics(new BABYLON.Vector3(0, 0, 0), new BABYLON.AmmoJSPlugin(false));

                const physicsEngine = scene.getPhysicsEngine()
                // physicsEngine.setSubTimeStep(physicsEngine.getTimeStep()/3 * 1000)
                physicsEngine.setTimeStep(1 / 60)
                physicsEngine.setSubTimeStep(1)
            
                //LIGHTS
                const light1 = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 5,-6), scene);
                const light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(6, 5, 3.5), scene);
                const light3 = new BABYLON.DirectionalLight("light3", new BABYLON.Vector3(20, -5, 20), scene);
                light1.intensity = 15;
                light2.intensity = 5;
            
                engine.displayLoadingUI();

                await BABYLON.SceneLoader.AppendAsync("3d/marbleTower.glb");

                const tower = scene.getMeshByName("tower");
                tower.setParent(null);
                tower.impostor = new BABYLON.PhysicsImpostor(tower, BABYLON.PhysicsImpostor.MeshImpostor, {
                    mass: 0,
                    friction: 1
                }, scene);
                

                /* CREATURE */
                const creature = BABYLON.MeshBuilder.CreateSphere("creature", {diameter: 1, segments: 32}, scene)
                creature.setParent(null)
                creature.isPickable = false

                const crMat = new BABYLON.StandardMaterial("cr_mat", scene);
                crMat.alpha = 0 // for screenshots
                creature.material = crMat

                creature.impostor = new BABYLON.PhysicsImpostor(creature, BABYLON.PhysicsImpostor.SphereImpostor, {
                    mass: 1,
                    friction: 0,
                    stiffness: 0,
                    restitution: 0
                }, scene);
                
                BABYLON.ParticleHelper.SnippetUrl = "3d/snippet";

                // Sparks
                creature.sparks = await BABYLON.ParticleHelper.CreateFromSnippetAsync("UY098C-3.json", scene, false);
                creature.sparks.emitter = creature;
                
                // Core
                creature.glow = await BABYLON.ParticleHelper.CreateFromSnippetAsync("EXUQ7M-5.json", scene, false);
                creature.glow.emitter = creature;


                /* CREATURE's CAMERA */
                // const crCameraMesh = BABYLON.MeshBuilder.CreateSphere("cr_camera_mesh", {diameter: 1, segments: 32}, scene);
                // crCameraMesh.setParent(creature)
                // crCameraMesh.isVisible = 0

                const crCamera = new BABYLON.UniversalCamera("cr_camera", new BABYLON.Vector3(1, 0, 0), scene)
                crCamera.parent = creature
                crCamera.setTarget(new BABYLON.Vector3(2, 0, 0))

                /* CLIENT */
                const client = BABYLON.MeshBuilder.CreateSphere("client", {diameter: 3, segments: 32}, scene);
                client.setParent(camera);
                client.position = new BABYLON.Vector3(0, -12,0)

                const clMat = new BABYLON.StandardMaterial("cl_mat", scene)
                clMat.diffuseColor = new BABYLON.Color3(0, 0, 0)
                client.material = clMat
                

                engine.hideLoadingUI();

                
                /* ANIMATION */
                // const rand = (min, max) => Math.random() * (max - min) + min
                // ;(() => {
                //     let start = Date.now()
                //     scene.registerBeforeRender(() => {
                //         const elapsed = Date.now() - start
                //         if (elapsed < 1000) return
                //         start = Date.now()

                //         const range = [-0.5, 0.5]
                //         var vec = new BABYLON.Vector3(rand(...range), rand(...range), rand(...range));
                //         creature.impostor.applyImpulse(vec, BABYLON.Vector3.Zero());
                        
                //         // const rotRange = [-Math.PI/209, Math.PI/209]
                //         // creature.addRotation(rand(...rotRange), rand(...rotRange), rand(...rotRange))

                //         creature.glow.color2 = new BABYLON.Color4(Math.random(), Math.random(), Math.random());
                //     })
                // })()

                /* CAGE */
                const cage = BABYLON.MeshBuilder.CreateBox("cage", {
                    width: 35, 
                    depth: 35, 
                    height: 40
                }, scene)
                cage.setParent(null)
                cage.position = new BABYLON.Vector3(0, -12,0)
                // cage.isVisible = false
                cage.isPickable = true

                const cageMat = new BABYLON.StandardMaterial("cage_mat", scene);
                cageMat.alpha = 0 // for ray hit
                cage.material = cageMat

                cage.impostor = new BABYLON.PhysicsImpostor(cage, BABYLON.PhysicsImpostor.MeshImpostor, {
                    mass: 0,
                    friction: 1
                }, scene);


                /* MIRROR */
                /* const mirror = BABYLON.MeshBuilder.CreateBox("mirror", {
                    width: 10, 
                    depth: 0.1, 
                    height: 5
                }, scene)
                mirror.material = new BABYLON.StandardMaterial("mirror_mat", scene)
                mirror.position = new BABYLON.Vector3(20, 0, 0)
                // mirror.addRotation(0, Math.PI/2, 0)
                mirror.isVisible = true
                // How to use: mirror.material.diffuseTexture = new BABYLON.Texture(base64Data, scene) // timer ~1ms
                */


                /* WORKER */
                const worker = new Worker('worker.js')
                worker.addEventListener('message', e => {
                    const { weights } = e.data
                    if (weights)
                        tf.tidy(() => {
                            agent.actor.setWeights(weights.map(w => tf.tensor(w))) // timer ~30ms
                        })
                })


                /* COLLISIONS DETECTION */
                const impostors = scene.getPhysicsEngine()._impostors.filter(im => im.object.id !== creature.id)
                creature.impostor.registerOnPhysicsCollide(impostors /* tower.impostor */, (body1, body2) => {})

                let collision = BABYLON.Vector3.Zero()
                creature.impostor.onCollide = e => {
                    const 
                        { x: x0, y: y0, z: z0 } = creature.position,
                        { x, y, z } = e.point
                    
                    collision = new BABYLON.Vector3(x - x0, y - y0, z - z0).normalize()
                    //print(collision.x, collision.y, collision.z)
                }

                const base64ToImg = (base64) => new Promise((res, _) => {
                    const img = new Image()
                    img.src = base64
                    img.onload = () => res(img)
                })
                const TRANSITIONS_BUFFER_SIZE = 2
                const scalar255 = tf.scalar(255)
                const frameEvery = 1000/24 // ~41ms ~24frames/sec
                const frameStack = []
                const transitions = []

                let start = Date.now() + frameEvery
                let busy = false
                let stateId = 0

                let rewardCombo = 0
                let maxCombo = 0

                scene.registerAfterRender(async () => { // timer ~ 20-90ms
                    if (Date.now() < start || busy) return
                    start = Date.now() + frameEvery
                    busy = true

                    const timerLbl = 'TimerLabel-' + start
                    
                    /*
                    console.time(timerLbl)
                    console.timeEnd(timerLbl)
                    console.log('numTensors BEFORE: ' + tf.memory().numTensors)
                    console.log('numTensors AFTER: ' + tf.memory().numTensors)
                    */

                    const base64Data = await BABYLON.Tools.CreateScreenshotUsingRenderTargetAsync(engine, crCamera, { // ~ 7-60ms
                        height: 64,
                        width: 128 
                    })

                    frameStack.push(base64Data)

                    if (frameStack.length >= agent._nFrames) { // ~20ms
                        if (frameStack.length > agent._nFrames)
                            throw new Error("(⊙＿⊙')")

                        const imgs = await Promise.all(frameStack.map(base64Data => base64ToImg(base64Data)))
                        const imgTensors = imgs.map(img => tf.browser.fromPixels(img))
                        // tf.browser.toPixels(tensors[0], document.getElementById("testCanvas")) // timer ~1ms
        
                        const frames = tf.concat(imgTensors, 2)
                        const framesNorm = frames.div(scalar255)
                        const framesBatch = tf.stack([framesNorm])

                        const linearVelocity = creature.impostor.getLinearVelocity().normalize()
                        const ray = new BABYLON.Ray(creature.position, linearVelocity)
                        const hit = scene.pickWithRay(ray)
                        let lidar = 0
                        if (hit.pickedMesh) {
                            lidar = Math.tanh(hit.distance - creature.impostor.getRadius())
                            print('Hit: ', hit.pickedMesh.name, hit.distance, lidar, linearVelocity, collision)
                        }

                        const telemetry = [
                            linearVelocity.x,
                            linearVelocity.y,
                            linearVelocity.z,
                            collision.x,
                            collision.y,
                            collision.z,
                            lidar
                        ]

                        let reward = 0
                        if (collision.x || collision.y || collision.z) {
                            rewardCombo = 0
                            reward = -1
                        } else {
                            rewardCombo++
                            if (rewardCombo > maxCombo) {
                                maxCombo = rewardCombo
                                // reward = +1
                                print('reward COMBO!!! ', maxCombo)
                            }
                        }

                        print('reward: ', reward, maxCombo)

                        collision = BABYLON.Vector3.Zero() // reset collision point
                        const telemetryBatch = tf.tensor(telemetry, [1, agent._nTelemetry])

                        const action = agent.sampleAction([framesBatch, telemetryBatch]) // timer ~5ms
                        // TODO: find the way to avoid framesNorm.array()
                        const [framesArr, [actionArr]] = await Promise.all([framesNorm.array(), action.array()]) // action come as a batch of size 1
                        
                        const 
                            impulse = actionArr.slice(0, 3).map(v => v),
                            rotation = actionArr.slice(3, 7).map(el => el),
                            color = actionArr.slice(7, 10) //.map(el => el) // [-1,1] => [0,2] => [0, 255]
                        
                        console.assert(actionArr.length === 10)
                        console.assert(impulse.length === 3)
                        console.assert(rotation.length === 4)
                        console.assert(color.length === 3)

                        creature.impostor.setAngularVelocity(BABYLON.Quaternion.Zero()) // just in case
                        creature.impostor.applyImpulse(new BABYLON.Vector3(...impulse), BABYLON.Vector3.Zero()) // contact point zero
                        creature.impostor.setAngularVelocity(BABYLON.Quaternion.Zero())
                        creature.rotationQuaternion = new BABYLON.Quaternion(...rotation)
                        creature.glow.color2 = new BABYLON.Color4(...color)

                        // creature.impostor.applyImpulse(new BABYLON.Vector3(0,-0.1,0), BABYLON.Vector3.Zero())
                        //creature.moveWithCollisions(new BABYLON.Vector3(0,-0.1,0))





                        // creature.impostor.applyImpulse(new BABYLON.Vector3(1,0,0), BABYLON.Vector3.Zero()) // contact point zero

                        // creature.impostor.setLinearVelocity(new BABYLON.Vector3(...impulse));
                        // creature.impostor.setAngularVelocity(new BABYLON.Quaternion(...rotation, 0));
                        // rotation = [-1,0,0]

                        // crCameraMesh.position = BABYLON.Vector3.Zero()
                        // const target = crCameraMesh.getAbsolutePosition()
                            // .add(new BABYLON.Vector3(...rotation))

                        // const target = new BABYLON.Vector3([0,-5,0])

                        // crCamera.setTarget(target)

                        // print(target, crCamera.getTarget(), new BABYLON.Vector3(...rotation))


                        // crCameraMesh.translate(target, 1, BABYLON.Space.LOCAL)
                        // crCameraMesh.isVisible = true
                        // crMat.alpha = 1





                        transitions.push({
                            id: stateId++, 
                            state: [framesArr, telemetry], // 20ms vs 50ms || size 200kb vs 1.5mb
                            action: actionArr,
                            reward
                        })

                        if (transitions.length >= TRANSITIONS_BUFFER_SIZE) {
                            if (transitions.length > TRANSITIONS_BUFFER_SIZE)
                                throw new Error("(⊙＿⊙')")

                            const transition = transitions.shift()

                            worker.postMessage({action: 'newTransition', transition}) // timer ~ 6ms
                        }

                        imgTensors.forEach(t => t.dispose())
                        frames.dispose()
                        framesNorm.dispose()
                        framesBatch.dispose()
                        telemetryBatch.dispose()
                        action.dispose()

                        // if (stateId%10 == 0)
                        //     frameStack.forEach((base64Data, i) => {
                        //         const img = new Image()
                        //         img.onload = () => document.getElementById('testCanvas' + i)
                        //             .getContext('2d')
                        //             .drawImage(img, 0, 0, 256, 128)
                        //         img.src = base64Data
                        //     })

                        frameStack.length = 0 // I will regret about this :D
                    }

                    /* Creature's POV */
                    ;(() => {
                        const img = new Image()
                        img.onload = () => document.getElementById('testCanvas3')
                            .getContext('2d')
                            .drawImage(img, 0, 0, 256, 128)
                        img.src = base64Data
                    })()

                    //mirror.material.diffuseTexture = new BABYLON.Texture(base64Data, scene) // timer ~1ms
                    
                    // const img = await base64ToImg(base64Data) // timer ~2-12ms
                    // const tensor = tf.browser.fromPixels(img) // timer ~ 1ms
                    // const arr = await tensor.array() // timer ~ 6-15ms
                    // worker.postMessage(arr) // timer ~ 6ms
                    // tensor.dispose()
                    
                    busy = false
                })

                return scene
            };

            window.initFunction = async function() {
                await Ammo();
                
                const asyncEngineCreation = async function() {
                    try {
                        return createDefaultEngine();
                    } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                    }
                }

                window.engine = await asyncEngineCreation();

                if (!engine) throw 'engine should not be null.';

                window.scene = await createScene();
            };

            initFunction().then(() => {
                sceneToRender = scene;
                engine.runRenderLoop(function () {
                    if (sceneToRender && sceneToRender.activeCamera) {
                        sceneToRender.render();
                    }
                });
            });

            window.addEventListener("resize", function () {
                engine.resize();
            });
        </script>
    </body>
</html>
